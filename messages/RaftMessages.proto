syntax = "proto3";

package Raft;

enum MessageType {
  REQUESTVOTE = 0;
  VOTERESULT = 1;
  APPENDENTRIES = 3;
  APPENDREPLY = 4;
}

message RequestVote {
  string fromAddr = 1;      // candidate ip address
  int32 fromPort = 2;
  string toAddr = 3;
  int32 toPort = 4;
  int32 term = 5;
  int32 lastLogIndex = 6;
  int32 lastLogTerm = 7;
};

message VoteResult {
  string fromAddr = 1;
  int32 fromPort = 2;
  string toAddr = 3;
  int32 toPort = 4;
  int32 term = 5;
  bool granted = 6;
};

message AppendEntries {
  string fromAddr = 1;            // leader ip address
  int32 fromPort = 2;
  string toAddr = 3;
  int32 toPort = 4;
  int32 term = 5;
  string info = 6;
  int32 prevLogIndex = 7;
  int32 prevLogTerm = 8;
  repeated LogEntry entries = 9;  // entries to be committed
  int32 leaderCommit = 10;
};

message AppendReply {
  string fromAddr = 1;
  int32 fromPort = 2;
  string toAddr = 3;
  int32 toPort = 4;
  int32 term = 5;
  bool success = 6;     // true if follower contained entry matching prevLogIndex and prevLogTerm
};

message WrapperMessage {
  MessageType type = 1;
  RequestVote rvm = 2;
  VoteResult vrm = 3;
  AppendEntries aem = 4;
  AppendReply arm = 5;
};

// Will be replaced with python dictionaries
// This message will be deleted soon if not needed
message LogEntries {
  repeated AppendEntries entry = 1;
}

message LogEntry {
  bool committed = 1;
  // string data = 2;        // this is a placeholder for the command
  int32 creationTerm = 3;
  int32 logPosition = 4;  // this is the same as the key for this entry in the dict
}

// the persistent state for each server that is written to disk every time we
// send a message
message serverState {
  int32 currentTerm = 1;
  string ipVotedFor = 2;  // the ip of the candidate that this server voted for this term
}
